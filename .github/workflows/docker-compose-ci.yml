# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Copilot-for-Consensus contributors

name: Docker Compose CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository }}/
  # Use mock LLM backend in CI for fast, reliable tests
  # Real LLM (LocalLLMSummarizer) is tested in unit/integration tests
  LLM_BACKEND: mock
  # Disable JWT authentication for integration testing (OAuth not available in CI)
  # JWT auth is tested separately in unit/integration tests for each service
  JWT_AUTH_ENABLED: "false"

jobs:
  # Test docker-compose with cached images
  test-docker-compose:
    name: Test Docker Compose
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

    - name: Create test secrets for CI
      run: |
        mkdir -p secrets

        # Message bus credentials
        echo "guest" > secrets/message_bus_user
        echo "guest" > secrets/message_bus_password
        echo "guest" > secrets/rabbitmq_user
        echo "guest" > secrets/rabbitmq_pass

        # MongoDB credentials
        echo "root" > secrets/document_database_user
        echo "example" > secrets/document_database_password
        echo "root" > secrets/mongodb_root_username
        echo "example" > secrets/mongodb_root_password

        # Grafana admin
        echo "admin" > secrets/grafana_admin_user
        echo "admin" > secrets/grafana_admin_password

        # Auth service secrets
        if [ ! -f secrets/jwt_private_key ]; then
          openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out secrets/jwt_private_key
          openssl rsa -pubout -in secrets/jwt_private_key -out secrets/jwt_public_key
        fi
        echo "" > secrets/jwt_secret_key  # Empty for RS256
        echo "" > secrets/github_oauth_client_id
        echo "" > secrets/github_oauth_client_secret
        echo "" > secrets/google_oauth_client_secret
        echo "" > secrets/microsoft_oauth_client_secret
        echo "example" > secrets/role_store_password

        # Azure OpenAI (empty for CI)
        echo "" > secrets/azure_openai_key

        # Generate self-signed TLS certificates for gateway (HTTPS)
        echo "Generating self-signed TLS certificates for gateway..."
        openssl req -x509 -newkey rsa:2048 \
          -keyout secrets/gateway_tls_key -out secrets/gateway_tls_cert \
          -days 365 -nodes \
          -subj "/C=US/ST=State/L=City/O=Copilot-for-Consensus/CN=localhost"
        echo "✓ TLS certificates generated"

    - name: Free up disk space
      run: |
        echo "Disk space before cleanup:"
        df -h
        # Remove unnecessary software to free up ~10GB
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /opt/ghc
        sudo rm -rf /opt/hostedtoolcache/CodeQL
        sudo docker system prune -af --volumes
        echo "Disk space after cleanup:"
        df -h

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3
      with:
        # Enable BuildKit cache backend for faster builds
        driver-opts: |
          image=moby/buildkit:latest
          network=host

    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: Clean up any existing containers and volumes
      run: |
        # Stop and remove any existing containers and volumes from previous runs
        docker compose down -v || true
        # Also remove any dangling containers
        docker container prune -f || true

    - name: Validate docker-compose configuration
      run: docker compose config

    # Build all services in parallel with cache for faster builds
    - name: Build all services in parallel
      env:
        DOCKER_BUILDKIT: 1
        COMPOSE_DOCKER_CLI_BUILD: 1
        BUILDKIT_PROGRESS: plain
      run: |
        set -euo pipefail
        echo "Building all services in parallel..."
        # Use --parallel flag to build multiple services at once
        docker compose build --parallel
        echo "✓ All services built successfully"

    # Infrastructure Services - Start in parallel for faster startup
    - name: Start core infrastructure services in parallel
      run: |
        echo "Starting core infrastructure services in parallel..."
        docker compose up -d documentdb messagebus vectorstore ollama monitoring pushgateway loki
        echo "Waiting for services to become healthy..."
        
        # Wait for each service with healthcheck to become healthy
        for service in documentdb messagebus vectorstore ollama monitoring pushgateway; do
          echo "Waiting for $service..."
          timeout 60s bash -c "until docker compose ps $service --format '{{.Status}}' | grep -q '(healthy)'; do sleep 3; done" || {
            echo "❌ $service failed to become healthy"
            docker compose logs $service --tail=50
            exit 1
          }
          echo "✓ $service is healthy"
        done
        
        # Wait for loki (no healthcheck, just needs to be Up)
        echo "Waiting for loki..."
        timeout 60s bash -c 'until docker compose ps loki --format "{{.Status}}" | grep -q "Up"; do sleep 3; done' || {
          echo "❌ loki failed to start"
          docker compose logs loki --tail=50
          exit 1
        }
        echo "✓ loki is running"
        echo "✓ All core infrastructure services ready"

    - name: Start dependent infrastructure services in parallel
      run: |
        echo "Starting dependent infrastructure services in parallel..."
        docker compose up -d mongodb-exporter promtail document-processing-exporter
        
        # Wait for services to be Up (these have no healthchecks)
        for service in mongodb-exporter document-processing-exporter; do
          echo "Waiting for $service..."
          timeout 60s bash -c "until docker compose ps $service --format '{{.Status}}' | grep -q 'Up'; do sleep 3; done" || {
            echo "❌ $service failed to start"
            docker compose logs $service --tail=50
            exit 1
          }
          echo "✓ $service is running"
        done
        
        # Wait for promtail (has healthcheck)
        echo "Waiting for promtail..."
        timeout 60s bash -c 'until docker compose ps promtail --format "{{.Status}}" | grep -q "(healthy)"; do sleep 3; done' || {
          echo "❌ promtail failed to become healthy"
          docker compose logs promtail --tail=50
          exit 1
        }
        echo "✓ promtail is healthy"
        echo "✓ All dependent infrastructure services ready"

    - name: Create placeholder public key for Grafana JWT auth
      run: |
        # Create a placeholder public key file for Grafana
        # This will be replaced by the actual public key from auth service later
        # Using the jwt_public_key we generated earlier as a placeholder
        cp secrets/jwt_public_key secrets/auth_service_public_key.pem
        echo "✓ Placeholder public key created for Grafana"

    - name: Start grafana
      run: |
        docker compose up -d grafana
        timeout 90s bash -c 'until docker compose ps grafana --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for grafana..."; sleep 3; done' || (docker compose logs grafana --tail=50 && exit 1)

    # Validator Services (run in parallel for faster validation)
    - name: Run validation services in parallel
      run: |
        echo "Running validation services in parallel..."
        # Start all validators in background
        docker compose run --rm db-init &
        pid_init=$!
        docker compose run --rm db-validate &
        pid_validate=$!
        docker compose run --rm vectorstore-validate &
        pid_vector=$!
        docker compose run --rm ollama-validate &
        pid_ollama=$!
        
        # Wait for all validators to complete
        failed=0
        wait $pid_init || { echo "❌ db-init failed"; failed=1; }
        wait $pid_validate || { echo "❌ db-validate failed"; failed=1; }
        wait $pid_vector || { echo "❌ vectorstore-validate failed"; failed=1; }
        wait $pid_ollama || { echo "❌ ollama-validate failed"; failed=1; }
        
        # Show logs for debugging
        docker compose logs db-init --tail=20 || true
        docker compose logs db-validate --tail=20 || true
        docker compose logs vectorstore-validate --tail=20 || true
        docker compose logs ollama-validate --tail=20 || true
        
        if [ $failed -eq 1 ]; then
          echo "❌ One or more validators failed"
          exit 1
        fi
        echo "✓ All validators passed"

    # Application Services
    # Start auth service first (other services may depend on it)
    - name: Start auth
      run: |
        echo "Starting auth service..."
        docker compose up -d auth
        echo "Waiting for auth service to become healthy..."
        timeout 120s bash -c 'until docker compose ps auth --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for auth..."; sleep 3; done' || {
          echo "❌ Auth service failed to become healthy"
          echo "=== Auth Service Status ==="
          docker compose ps auth
          echo ""
          echo "=== Auth Service Logs (last 100 lines) ==="
          docker compose logs auth --tail=100
          exit 1
        }
        echo "✓ Auth service is healthy"

    # Start independent processing services in parallel
    - name: Start processing services in parallel
      run: |
        echo "Starting processing services in parallel..."
        docker compose up -d parsing chunking embedding summarization
        
        # Wait for all processing services to become healthy
        for service in parsing chunking embedding summarization; do
          echo "Waiting for $service..."
          timeout 120s bash -c "until docker compose ps $service --format '{{.Status}}' | grep -q '(healthy)'; do sleep 3; done" || {
            echo "❌ $service failed to become healthy"
            docker compose logs $service --tail=50
            exit 1
          }
          echo "✓ $service is healthy"
        done
        echo "✓ All processing services ready"

    # Start orchestrator and reporting (depend on processing services)
    - name: Start orchestrator and reporting
      run: |
        echo "Starting orchestrator and reporting services..."
        docker compose up -d orchestrator reporting
        
        for service in orchestrator reporting; do
          echo "Waiting for $service..."
          timeout 120s bash -c "until docker compose ps $service --format '{{.Status}}' | grep -q '(healthy)'; do sleep 3; done" || {
            echo "❌ $service failed to become healthy"
            docker compose logs $service --tail=50
            exit 1
          }
          echo "✓ $service is healthy"
        done
        echo "✓ Orchestrator and reporting ready"

    # Start UI and ingestion services
    - name: Start ui and ingestion
      run: |
        echo "Starting ui and ingestion services..."
        docker compose up -d ui ingestion
        
        for service in ui ingestion; do
          echo "Waiting for $service..."
          timeout 120s bash -c "until docker compose ps $service --format '{{.Status}}' | grep -q '(healthy)'; do sleep 3; done" || {
            echo "❌ $service failed to become healthy"
            docker compose logs $service --tail=50
            exit 1
          }
          echo "✓ $service is healthy"
        done
        echo "✓ UI and ingestion services ready"

    # Start gateway last (after all backend services are ready)
    - name: Start gateway
      run: |
        echo "Starting gateway..."
        docker compose up -d gateway
        timeout 120s bash -c 'until docker compose ps gateway --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for gateway..."; sleep 3; done' || {
          echo "❌ Gateway failed to become healthy"
          docker compose logs gateway --tail=50
          exit 1
        }
        echo "✓ Gateway is healthy"

    - name: Check service status
      run: docker compose ps

    - name: Copy test mailbox into ingestion container
      run: |
        set -euo pipefail
        INGESTION_CONTAINER=$(docker compose ps -q ingestion)
        if [ -z "$INGESTION_CONTAINER" ]; then
          echo "❌ Ingestion container not running"
          exit 1
        fi

        docker exec "$INGESTION_CONTAINER" mkdir -p /tmp/test-mailbox
        docker cp tests/fixtures/mailbox_sample/test-archive.mbox "$INGESTION_CONTAINER":/tmp/test-mailbox/test-archive.mbox
        echo "✓ Test mailbox copied to ingestion container"

    - name: Create ingestion source via API
      run: |
        set -euo pipefail
        echo "Creating ingestion source via REST API..."

        # Generate a test JWT token with admin role
        # First, get the public key from the auth service
        PUBLIC_KEY=$(curl -s http://localhost:8080/auth/keys | python -c 'import json,sys; data=json.load(sys.stdin); print(data.get("keys", [{}])[0].get("x5c", [""])[0])' 2>/dev/null || echo "")

        # For CI without proper OAuth, we use the disabled JWT auth mode
        # If JWT is disabled, we can make requests without tokens
        # If JWT is enabled, the test infrastructure should provide mock tokens

        payload='{"name":"test-mailbox","source_type":"local","url":"/tmp/test-mailbox/test-archive.mbox","enabled":true}'
        max_attempts=5
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          # Try without auth first (if JWT_AUTH_ENABLED=false)
          if curl -k -f -X POST https://localhost/ingestion/api/sources \
            -H "Content-Type: application/json" \
            -d "$payload" 2>/dev/null; then
            echo "✓ Ingestion source created (no auth required)"
            break
          fi

          # If that fails, try with a mock auth header for compatibility
          if curl -k -f -X POST https://localhost/ingestion/api/sources \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer test-token" \
            -d "$payload" 2>/dev/null; then
            echo "✓ Ingestion source created (with mock token)"
            break
          fi

          echo "Attempt $attempt/$max_attempts: Failed to create source, retrying..."
          sleep 2
          attempt=$((attempt + 1))
        done

        if [ $attempt -gt $max_attempts ]; then
          echo "❌ Failed to create ingestion source after $max_attempts attempts"
          docker compose logs ingestion --tail=50
          exit 1
        fi

    - name: Trigger ingestion via API
      run: |
        set -euo pipefail
        echo "Triggering ingestion for test source via REST API..."
        max_attempts=5
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          # Try without auth first (if JWT_AUTH_ENABLED=false)
          if curl -k -f -X POST https://localhost/ingestion/api/sources/test-mailbox/trigger 2>/dev/null; then
            echo "✓ Ingestion triggered successfully (no auth required)"
            break
          fi

          # If that fails, try with a mock auth header for compatibility
          if curl -k -f -X POST https://localhost/ingestion/api/sources/test-mailbox/trigger \
            -H "Authorization: Bearer test-token" 2>/dev/null; then
            echo "✓ Ingestion triggered successfully (with mock token)"
            break
          fi

          echo "Attempt $attempt/$max_attempts: Failed to trigger ingestion, retrying..."
          sleep 2
          attempt=$((attempt + 1))
        done

        if [ $attempt -gt $max_attempts ]; then
          echo "❌ Failed to trigger ingestion after $max_attempts attempts"
          docker compose logs ingestion --tail=50
          exit 1
        fi

        # Wait for ingestion to complete (check status)
        echo "Waiting for ingestion to complete..."
        sleep 10  # Give it time to process

        # Check ingestion status
        status=$(curl -k -s https://localhost/ingestion/api/sources/test-mailbox/status || echo "unknown")
        echo "Ingestion status: $status"
        echo "✓ Ingestion process completed"

    - name: View ingestion logs
      if: always()
      run: docker compose logs ingestion

    - name: View service logs on validation failure
      if: failure()
      run: |
        echo "=== Parsing Service Logs ==="
        docker compose logs parsing --tail=100
        echo ""
        echo "=== Chunking Service Logs ==="
        docker compose logs chunking --tail=100
        echo ""
        echo "=== Embedding Service Logs ==="
        docker compose logs embedding --tail=100
        echo ""
        echo "=== Orchestrator Service Logs ==="
        docker compose logs orchestrator --tail=100

    - name: Test service health endpoints
      run: |
        echo "Testing service health endpoints via gateway..."
        
        # Test gateway health
        echo "Testing gateway health..."
        if ! curl -k -f https://localhost/health 2>/dev/null; then
          echo "❌ Gateway health check failed"
          docker compose logs gateway --tail=50
          exit 1
        fi
        echo "✓ Gateway is healthy"
        
        # Test reporting service
        echo "Testing reporting service..."
        if ! curl -k -f https://localhost/reporting/health 2>/dev/null; then
          echo "❌ Reporting service health check failed"
          docker compose logs reporting --tail=50
          exit 1
        fi
        echo "✓ Reporting service is healthy"
        
        # Test auth service
        echo "Testing auth service..."
        if ! curl -k -f https://localhost/auth/health 2>/dev/null; then
          echo "❌ Auth service health check failed"
          docker compose logs auth --tail=50
          exit 1
        fi
        echo "✓ Auth service is healthy"
        
        # Test UI service
        echo "Testing ui service..."
        if ! curl -k -f https://localhost/ui/ 2>/dev/null; then
          echo "❌ UI service check failed"
          docker compose logs ui --tail=50
          exit 1
        fi
        echo "✓ UI service is accessible"
        
        echo "✓ All service health checks passed"
        while [ $attempt -le $max_attempts ]; do
          if curl -k -f https://localhost/auth/health 2>/dev/null; then
            echo "✓ Auth service is healthy"
            exit 0
          fi
          echo "Attempt $attempt/$max_attempts: Auth service not responding yet..."
          sleep 3
          attempt=$((attempt + 1))
        done
        echo "❌ Auth service failed to respond after $max_attempts attempts"
        docker compose logs auth --tail=50
        exit 1

    - name: Validate reports are generated (end-to-end)
      run: |
        echo "Validating reports exist after end-to-end run..."
        # Fetch reports JSON and assert count > 0 (black-box via reporting API)
        json=$(curl -k -s https://localhost/reporting/api/reports)
        echo "$json" | python -c 'import json,sys; data=json.load(sys.stdin); cnt=data.get("count",0); print(f"Reports count: {cnt}"); exit(0 if cnt>0 else 1)'
        echo "✓ Reports validation passed"

    - name: Test monitoring endpoints
      run: |
        echo "Testing monitoring services..."
        
        # Test Grafana
        echo "Testing Grafana (via gateway)..."
        if ! curl -k -f https://localhost/grafana/api/health 2>/dev/null; then
          echo "❌ Grafana health check failed"
          exit 1
        fi
        echo "✓ Grafana is healthy"
        
        # Test Prometheus
        echo "Testing Prometheus..."
        if ! curl -f http://localhost:9090/-/healthy 2>/dev/null; then
          echo "❌ Prometheus health check failed"
          exit 1
        fi
        echo "✓ Prometheus is healthy"
        
        # Test Loki
        echo "Testing Loki..."
        if ! curl -f http://localhost:3100/ready 2>/dev/null; then
          echo "❌ Loki readiness check failed"
          exit 1
        fi
        echo "✓ Loki is ready"
        
        echo "✓ All monitoring endpoints are healthy"

    - name: View service logs
      if: always()
      run: docker compose logs --tail=50

    - name: Stop all services
      if: always()
      run: docker compose down

    - name: Verify clean shutdown
      if: always()
      run: |
        echo "Verifying all containers stopped..."
        if [ "$(docker compose ps -q | wc -l)" -eq 0 ]; then
          echo "✓ All services stopped successfully"
        else
          echo "✗ Some services failed to stop"
          docker compose ps
          exit 1
        fi
