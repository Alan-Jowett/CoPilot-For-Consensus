# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Copilot-for-Consensus contributors

name: Docker Compose CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository }}/
  # Use mock LLM backend in CI for fast, reliable tests
  # Real LLM (LocalLLMSummarizer) is tested in unit/integration tests
  LLM_BACKEND: mock

jobs:
  # Test docker-compose with cached images
  test-docker-compose:
    name: Test Docker Compose
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

    - name: Free up disk space
      run: |
        echo "Disk space before cleanup:"
        df -h
        # Remove unnecessary software to free up ~10GB
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /opt/ghc
        sudo rm -rf /opt/hostedtoolcache/CodeQL
        sudo docker system prune -af --volumes
        echo "Disk space after cleanup:"
        df -h

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3

    - name: Clean up any existing containers and volumes
      run: |
        # Stop and remove any existing containers and volumes from previous runs
        docker compose down -v || true
        # Also remove any dangling containers
        docker container prune -f || true

    - name: Validate docker-compose configuration
      run: docker compose config

    # Build all services in parallel for faster CI times
    - name: Build all services in parallel
      env:
        DOCKER_BUILDKIT: 1
        COMPOSE_DOCKER_CLI_BUILD: 1
      run: docker compose build --parallel

    # Infrastructure Services
    - name: Start documentdb
      run: |
        docker compose up -d documentdb
        timeout 60s bash -c 'until docker compose ps documentdb --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for documentdb..."; sleep 3; done' || (docker compose logs documentdb --tail=50 && exit 1)

    - name: Start messagebus
      run: |
        docker compose up -d messagebus
        timeout 60s bash -c 'until docker compose ps messagebus --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for messagebus..."; sleep 3; done' || (docker compose logs messagebus --tail=50 && exit 1)

    - name: Start vectorstore
      run: |
        docker compose up -d vectorstore
        timeout 60s bash -c 'until docker compose ps vectorstore --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for vectorstore..."; sleep 3; done' || (docker compose logs vectorstore --tail=50 && exit 1)

    - name: Start ollama
      run: |
        docker compose up -d ollama
        timeout 60s bash -c 'until docker compose ps ollama --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for ollama..."; sleep 3; done' || (docker compose logs ollama --tail=50 && exit 1)

    - name: Start monitoring (Prometheus)
      run: |
        docker compose up -d monitoring
        timeout 60s bash -c 'until docker compose ps monitoring --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for monitoring..."; sleep 3; done' || (docker compose logs monitoring --tail=50 && exit 1)

    - name: Start pushgateway
      run: |
        docker compose up -d pushgateway
        timeout 60s bash -c 'until docker compose ps pushgateway --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for pushgateway..."; sleep 3; done' || (docker compose logs pushgateway --tail=50 && exit 1)

    - name: Start loki
      run: |
        docker compose up -d loki
        # Loki image is distroless and has no healthcheck, so wait for it to be running
        timeout 60s bash -c 'until docker compose ps loki --format "{{.Status}}" | grep -q "Up"; do echo "Waiting for loki..."; sleep 3; done' || (docker compose logs loki --tail=50 && exit 1)

    - name: Start grafana
      run: |
        docker compose up -d grafana
        timeout 90s bash -c 'until docker compose ps grafana --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for grafana..."; sleep 3; done' || (docker compose logs grafana --tail=50 && exit 1)

    - name: Start promtail
      run: |
        docker compose up -d promtail
        timeout 60s bash -c 'until docker compose ps promtail --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for promtail..."; sleep 3; done' || (docker compose logs promtail --tail=50 && exit 1)

    # Validator Services (one-shot containers)
    - name: Run db-init
      run: |
        docker compose run --rm db-init
        docker compose logs db-init --tail=20 || true

    - name: Run db-validate
      run: |
        docker compose run --rm db-validate
        docker compose logs db-validate --tail=20 || true

    - name: Run vectorstore-validate
      run: |
        docker compose run --rm vectorstore-validate
        docker compose logs vectorstore-validate --tail=20 || true

    - name: Run ollama-validate
      run: |
        docker compose run --rm ollama-validate
        docker compose logs ollama-validate --tail=20 || true

    # Application Services
    - name: Start parsing
      run: |
        docker compose up -d parsing
        timeout 120s bash -c 'until docker compose ps parsing --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for parsing..."; sleep 3; done' || (docker compose logs parsing --tail=50 && exit 1)

    - name: Start chunking
      run: |
        docker compose up -d chunking
        timeout 120s bash -c 'until docker compose ps chunking --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for chunking..."; sleep 3; done' || (docker compose logs chunking --tail=50 && exit 1)

    - name: Start embedding
      run: |
        docker compose up -d embedding
        timeout 120s bash -c 'until docker compose ps embedding --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for embedding..."; sleep 3; done' || (docker compose logs embedding --tail=50 && exit 1)

    - name: Start orchestrator
      run: |
        docker compose up -d orchestrator
        timeout 120s bash -c 'until docker compose ps orchestrator --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for orchestrator..."; sleep 3; done' || (docker compose logs orchestrator --tail=50 && exit 1)

    - name: Start summarization
      run: |
        docker compose up -d summarization
        timeout 120s bash -c 'until docker compose ps summarization --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for summarization..."; sleep 3; done' || (docker compose logs summarization --tail=50 && exit 1)

    - name: Start reporting
      run: |
        docker compose up -d reporting
        timeout 120s bash -c 'until docker compose ps reporting --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for reporting..."; sleep 3; done' || (docker compose logs reporting --tail=50 && exit 1)

    - name: Start reporting-ui
      run: |
        docker compose up -d reporting-ui
        timeout 120s bash -c 'until docker compose ps reporting-ui --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for reporting-ui..."; sleep 3; done' || (docker compose logs reporting-ui --tail=50 && exit 1)

    - name: Check service status
      run: docker compose ps

    - name: Upload test ingestion configuration
      run: |
        echo "Uploading test ingestion configuration..."
        docker compose run --rm \
          -v $PWD/tests/fixtures/mailbox_sample:/app/tests/fixtures/mailbox_sample:ro \
          ingestion \
          python /app/upload_ingestion_sources.py /app/tests/fixtures/mailbox_sample/ingestion-config.json
        echo "✓ Test configuration uploaded"

    - name: Run ingestion service (batch job)
      run: |
        echo "Running ingestion service (batch job - runs once and exits)..."
        docker compose run --rm \
          -v $PWD/tests/fixtures/mailbox_sample:/app/tests/fixtures/mailbox_sample:ro \
          ingestion
        echo "✓ Ingestion service completed successfully"

    - name: View ingestion logs
      if: always()
      run: docker compose logs ingestion

    - name: Validate end-to-end message flow
      run: |
        echo "Validating end-to-end message flow..."
        docker compose run --rm \
          -v $PWD/tests:/app/tests:ro \
          -e QDRANT_HOST=vectorstore \
          -e QDRANT_PORT=6333 \
          -e QDRANT_COLLECTION=embeddings \
          --entrypoint "" \
          embedding \
          bash -c "python /app/tests/validate_e2e_flow.py"
        echo "✓ End-to-end validation completed"

    - name: View service logs on validation failure
      if: failure()
      run: |
        echo "=== Parsing Service Logs ==="
        docker compose logs parsing --tail=100
        echo ""
        echo "=== Chunking Service Logs ==="
        docker compose logs chunking --tail=100
        echo ""
        echo "=== Embedding Service Logs ==="
        docker compose logs embedding --tail=100
        echo ""
        echo "=== Orchestrator Service Logs ==="
        docker compose logs orchestrator --tail=100

    - name: Test reporting service health endpoint
      run: |
        echo "Testing reporting service..."
        max_attempts=10
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          if curl -f http://localhost:8080/ 2>/dev/null; then
            echo "✓ Reporting service is healthy"
            exit 0
          fi
          echo "Attempt $attempt/$max_attempts: Reporting service not responding yet..."
          sleep 3
          attempt=$((attempt + 1))
        done
        echo "❌ Reporting service failed to respond after $max_attempts attempts"
        docker compose logs reporting --tail=50
        exit 1

    - name: Test reporting API endpoint
      run: |
        echo "Testing reports API..."
        curl -f http://localhost:8080/api/reports || (docker compose logs reporting --tail=50 && exit 1)

    - name: Validate reports are generated (end-to-end)
      run: |
        echo "Validating reports exist after end-to-end run..."
        # Fetch reports JSON and assert count > 0 (black-box via reporting API)
        json=$(curl -s http://localhost:8080/api/reports)
        echo "$json" | python -c 'import json,sys; data=json.load(sys.stdin); cnt=data.get("count",0); print(f"Reports count: {cnt}"); exit(0 if cnt>0 else 1)'
        echo "✓ Reports validation passed"

    - name: Test reporting-ui service health endpoint
      run: |
        echo "Testing reporting-ui service..."
        max_attempts=10
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          if curl -f http://localhost:8083/health 2>/dev/null; then
            echo "✓ Reporting-UI service is healthy"
            exit 0
          fi
          echo "Attempt $attempt/$max_attempts: Reporting-UI service not responding yet..."
          sleep 3
          attempt=$((attempt + 1))
        done
        echo "❌ Reporting-UI service failed to respond after $max_attempts attempts"
        docker compose logs reporting-ui --tail=50
        exit 1

    - name: Test reporting-ui reports page
      run: |
        echo "Testing reporting-ui reports page..."
        curl -f http://localhost:8083/reports || (docker compose logs reporting-ui --tail=50 && exit 1)

    - name: Test Grafana health endpoint
      run: |
        echo "Testing Grafana..."
        curl -f http://localhost:3000/api/health || exit 1

    - name: Test Prometheus health endpoint
      run: |
        echo "Testing Prometheus..."
        curl -f http://localhost:9090/-/healthy || exit 1

    - name: Test Loki health endpoint
      run: |
        echo "Testing Loki..."
        max_attempts=30
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          if curl -f http://localhost:3100/ready 2>/dev/null; then
            echo "Loki is ready"
            exit 0
          fi
          echo "Attempt $attempt/$max_attempts: Loki not ready yet, waiting..."
          sleep 5
          attempt=$((attempt + 1))
        done
        echo "Loki failed to become ready after $max_attempts attempts"
        exit 1

    - name: View service logs
      if: always()
      run: docker compose logs --tail=50

    - name: Stop all services
      if: always()
      run: docker compose down

    - name: Verify clean shutdown
      if: always()
      run: |
        echo "Verifying all containers stopped..."
        if [ "$(docker compose ps -q | wc -l)" -eq 0 ]; then
          echo "✓ All services stopped successfully"
        else
          echo "✗ Some services failed to stop"
          docker compose ps
          exit 1
        fi
