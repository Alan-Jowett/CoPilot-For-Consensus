# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Copilot-for-Consensus contributors

name: Docker Compose CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository }}/
  # Use mock LLM backend in CI for fast, reliable tests
  # Real LLM (LocalLLMSummarizer) is tested in unit/integration tests
  LLM_BACKEND: mock
  # Disable JWT authentication for integration testing (OAuth not available in CI)
  # JWT auth is tested separately in unit/integration tests for each service
  JWT_AUTH_ENABLED: "false"

jobs:
  # Test docker-compose with cached images
  test-docker-compose:
    name: Test Docker Compose
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

    - name: Create test secrets for CI
      run: |
        mkdir -p secrets

        # Message bus credentials
        echo "guest" > secrets/message_bus_user
        echo "guest" > secrets/message_bus_password
        echo "guest" > secrets/rabbitmq_user
        echo "guest" > secrets/rabbitmq_pass

        # MongoDB credentials
        echo "root" > secrets/document_database_user
        echo "example" > secrets/document_database_password
        echo "root" > secrets/mongodb_root_username
        echo "example" > secrets/mongodb_root_password

        # Grafana admin
        echo "admin" > secrets/grafana_admin_user
        echo "admin" > secrets/grafana_admin_password

        # Auth service secrets
        if [ ! -f secrets/jwt_private_key ]; then
          openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out secrets/jwt_private_key
          openssl rsa -pubout -in secrets/jwt_private_key -out secrets/jwt_public_key
        fi
        echo "" > secrets/jwt_secret_key  # Empty for RS256
        echo "" > secrets/github_oauth_client_id
        echo "" > secrets/github_oauth_client_secret
        echo "" > secrets/google_oauth_client_secret
        echo "" > secrets/microsoft_oauth_client_secret
        echo "example" > secrets/role_store_password

        # Azure OpenAI (empty for CI)
        echo "" > secrets/azure_openai_key

        # Generate self-signed TLS certificates for gateway (HTTPS)
        echo "Generating self-signed TLS certificates for gateway..."
        openssl req -x509 -newkey rsa:2048 \
          -keyout secrets/gateway_tls_key -out secrets/gateway_tls_cert \
          -days 365 -nodes \
          -subj "/C=US/ST=State/L=City/O=Copilot-for-Consensus/CN=localhost"
        echo "✓ TLS certificates generated"

    - name: Free up disk space
      run: |
        echo "Disk space before cleanup:"
        df -h
        # Remove unnecessary software to free up ~10GB
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /opt/ghc
        sudo rm -rf /opt/hostedtoolcache/CodeQL
        sudo docker system prune -af --volumes
        echo "Disk space after cleanup:"
        df -h

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3

    - name: Clean up any existing containers and volumes
      run: |
        # Stop and remove any existing containers and volumes from previous runs
        docker compose down -v || true
        # Also remove any dangling containers
        docker container prune -f || true

    - name: Validate docker-compose configuration
      run: docker compose config

    # Build all services in parallel for faster CI times
    - name: Build all services in parallel
      env:
        DOCKER_BUILDKIT: 1
        COMPOSE_DOCKER_CLI_BUILD: 1
      run: docker compose build --parallel

    # Infrastructure Services
    - name: Start documentdb
      run: |
        docker compose up -d documentdb
        timeout 60s bash -c 'until docker compose ps documentdb --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for documentdb..."; sleep 3; done' || (docker compose logs documentdb --tail=50 && exit 1)

    - name: Start mongodb-exporter
      run: |
        docker compose up -d mongodb-exporter
        # mongodb-exporter has no healthcheck, so wait for it to be running
        timeout 60s bash -c 'until docker compose ps mongodb-exporter --format "{{.Status}}" | grep -q "Up"; do echo "Waiting for mongodb-exporter..."; sleep 3; done' || (docker compose logs mongodb-exporter --tail=50 && exit 1)

    - name: Start messagebus
      run: |
        docker compose up -d messagebus
        timeout 60s bash -c 'until docker compose ps messagebus --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for messagebus..."; sleep 3; done' || (docker compose logs messagebus --tail=50 && exit 1)

    - name: Start vectorstore
      run: |
        docker compose up -d vectorstore
        timeout 60s bash -c 'until docker compose ps vectorstore --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for vectorstore..."; sleep 3; done' || (docker compose logs vectorstore --tail=50 && exit 1)

    - name: Start ollama
      run: |
        docker compose up -d ollama
        timeout 60s bash -c 'until docker compose ps ollama --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for ollama..."; sleep 3; done' || (docker compose logs ollama --tail=50 && exit 1)

    - name: Start monitoring (Prometheus)
      run: |
        docker compose up -d monitoring
        timeout 60s bash -c 'until docker compose ps monitoring --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for monitoring..."; sleep 3; done' || (docker compose logs monitoring --tail=50 && exit 1)

    - name: Start pushgateway
      run: |
        docker compose up -d pushgateway
        timeout 60s bash -c 'until docker compose ps pushgateway --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for pushgateway..."; sleep 3; done' || (docker compose logs pushgateway --tail=50 && exit 1)

    - name: Start loki
      run: |
        docker compose up -d loki
        # Loki image is distroless and has no healthcheck, so wait for it to be running
        timeout 60s bash -c 'until docker compose ps loki --format "{{.Status}}" | grep -q "Up"; do echo "Waiting for loki..."; sleep 3; done' || (docker compose logs loki --tail=50 && exit 1)

    - name: Create placeholder public key for Grafana JWT auth
      run: |
        # Create a placeholder public key file for Grafana
        # This will be replaced by the actual public key from auth service later
        # Using the jwt_public_key we generated earlier as a placeholder
        cp secrets/jwt_public_key secrets/auth_service_public_key.pem
        echo "✓ Placeholder public key created for Grafana"

    - name: Start grafana
      run: |
        docker compose up -d grafana
        timeout 90s bash -c 'until docker compose ps grafana --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for grafana..."; sleep 3; done' || (docker compose logs grafana --tail=50 && exit 1)

    - name: Start promtail
      run: |
        docker compose up -d promtail
        timeout 60s bash -c 'until docker compose ps promtail --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for promtail..."; sleep 3; done' || (docker compose logs promtail --tail=50 && exit 1)

    - name: Start document-processing-exporter
      run: |
        docker compose up -d document-processing-exporter
        # document-processing-exporter has no healthcheck, so wait for it to be running
        timeout 60s bash -c 'until docker compose ps document-processing-exporter --format "{{.Status}}" | grep -q "Up"; do echo "Waiting for document-processing-exporter..."; sleep 3; done' || (docker compose logs document-processing-exporter --tail=50 && exit 1)

    # Validator Services (one-shot containers)
    - name: Run db-init
      run: |
        docker compose run --rm db-init
        docker compose logs db-init --tail=20 || true

    - name: Run db-validate
      run: |
        docker compose run --rm db-validate
        docker compose logs db-validate --tail=20 || true

    - name: Run vectorstore-validate
      run: |
        docker compose run --rm vectorstore-validate
        docker compose logs vectorstore-validate --tail=20 || true

    - name: Run ollama-validate
      run: |
        docker compose run --rm ollama-validate
        docker compose logs ollama-validate --tail=20 || true

    # Application Services
    # Start auth service first (other services may depend on it)
    - name: Start auth
      run: |
        echo "Starting auth service..."
        docker compose up -d auth
        echo "Waiting for auth service to become healthy..."
        timeout 120s bash -c 'until docker compose ps auth --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for auth..."; sleep 3; done' || {
          echo "❌ Auth service failed to become healthy"
          echo "=== Auth Service Status ==="
          docker compose ps auth
          echo ""
          echo "=== Auth Service Logs (last 100 lines) ==="
          docker compose logs auth --tail=100
          exit 1
        }
        echo "✓ Auth service is healthy"

    - name: Start parsing
      run: |
        docker compose up -d parsing
        timeout 120s bash -c 'until docker compose ps parsing --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for parsing..."; sleep 3; done' || (docker compose logs parsing --tail=50 && exit 1)

    - name: Start chunking
      run: |
        docker compose up -d chunking
        timeout 120s bash -c 'until docker compose ps chunking --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for chunking..."; sleep 3; done' || (docker compose logs chunking --tail=50 && exit 1)

    - name: Start embedding
      run: |
        docker compose up -d embedding
        timeout 120s bash -c 'until docker compose ps embedding --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for embedding..."; sleep 3; done' || (docker compose logs embedding --tail=50 && exit 1)

    - name: Start orchestrator
      run: |
        docker compose up -d orchestrator
        timeout 120s bash -c 'until docker compose ps orchestrator --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for orchestrator..."; sleep 3; done' || (docker compose logs orchestrator --tail=50 && exit 1)

    - name: Start summarization
      run: |
        docker compose up -d summarization
        timeout 120s bash -c 'until docker compose ps summarization --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for summarization..."; sleep 3; done' || (docker compose logs summarization --tail=50 && exit 1)



    - name: Start reporting
      run: |
        docker compose up -d reporting
        timeout 120s bash -c 'until docker compose ps reporting --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for reporting..."; sleep 3; done' || (docker compose logs reporting --tail=50 && exit 1)

    - name: Start ui
      run: |
        docker compose up -d ui
        timeout 120s bash -c 'until docker compose ps ui --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for ui..."; sleep 3; done' || (docker compose logs ui --tail=50 && exit 1)

    - name: Start gateway
      run: |
        docker compose up -d gateway
        timeout 120s bash -c 'until docker compose ps gateway --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for gateway..."; sleep 3; done' || (docker compose logs gateway --tail=50 && exit 1)

    - name: Check service status
      run: docker compose ps

    - name: Start ingestion service
      run: |
        docker compose up -d ingestion
        timeout 120s bash -c 'until docker compose ps ingestion --format "{{.Status}}" | grep -q "(healthy)"; do echo "Waiting for ingestion service..."; sleep 3; done' || (docker compose logs ingestion --tail=50 && exit 1)
        echo "✓ Ingestion service started and healthy"

    - name: Copy test mailbox into ingestion container
      run: |
        set -euo pipefail
        INGESTION_CONTAINER=$(docker compose ps -q ingestion)
        if [ -z "$INGESTION_CONTAINER" ]; then
          echo "❌ Ingestion container not running"
          exit 1
        fi

        docker exec "$INGESTION_CONTAINER" mkdir -p /tmp/test-mailbox
        docker cp tests/fixtures/mailbox_sample/test-archive.mbox "$INGESTION_CONTAINER":/tmp/test-mailbox/test-archive.mbox
        echo "✓ Test mailbox copied to ingestion container"

    - name: Create ingestion source via API
      run: |
        set -euo pipefail
        echo "Creating ingestion source via REST API..."

        # Generate a test JWT token with admin role
        # First, get the public key from the auth service
        PUBLIC_KEY=$(curl -s http://localhost:8080/auth/keys | python -c 'import json,sys; data=json.load(sys.stdin); print(data.get("keys", [{}])[0].get("x5c", [""])[0])' 2>/dev/null || echo "")

        # For CI without proper OAuth, we use the disabled JWT auth mode
        # If JWT is disabled, we can make requests without tokens
        # If JWT is enabled, the test infrastructure should provide mock tokens

        payload='{"name":"test-mailbox","source_type":"local","url":"/tmp/test-mailbox/test-archive.mbox","enabled":true}'
        max_attempts=5
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          # Try without auth first (if JWT_AUTH_ENABLED=false)
          if curl -k -f -X POST https://localhost/ingestion/api/sources \
            -H "Content-Type: application/json" \
            -d "$payload" 2>/dev/null; then
            echo "✓ Ingestion source created (no auth required)"
            break
          fi

          # If that fails, try with a mock auth header for compatibility
          if curl -k -f -X POST https://localhost/ingestion/api/sources \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer test-token" \
            -d "$payload" 2>/dev/null; then
            echo "✓ Ingestion source created (with mock token)"
            break
          fi

          echo "Attempt $attempt/$max_attempts: Failed to create source, retrying..."
          sleep 2
          attempt=$((attempt + 1))
        done

        if [ $attempt -gt $max_attempts ]; then
          echo "❌ Failed to create ingestion source after $max_attempts attempts"
          docker compose logs ingestion --tail=50
          exit 1
        fi

    - name: Trigger ingestion via API
      run: |
        set -euo pipefail
        echo "Triggering ingestion for test source via REST API..."
        max_attempts=5
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          # Try without auth first (if JWT_AUTH_ENABLED=false)
          if curl -k -f -X POST https://localhost/ingestion/api/sources/test-mailbox/trigger 2>/dev/null; then
            echo "✓ Ingestion triggered successfully (no auth required)"
            break
          fi

          # If that fails, try with a mock auth header for compatibility
          if curl -k -f -X POST https://localhost/ingestion/api/sources/test-mailbox/trigger \
            -H "Authorization: Bearer test-token" 2>/dev/null; then
            echo "✓ Ingestion triggered successfully (with mock token)"
            break
          fi

          echo "Attempt $attempt/$max_attempts: Failed to trigger ingestion, retrying..."
          sleep 2
          attempt=$((attempt + 1))
        done

        if [ $attempt -gt $max_attempts ]; then
          echo "❌ Failed to trigger ingestion after $max_attempts attempts"
          docker compose logs ingestion --tail=50
          exit 1
        fi

        # Wait for ingestion to complete (check status)
        echo "Waiting for ingestion to complete..."
        sleep 10  # Give it time to process

        # Check ingestion status
        status=$(curl -k -s https://localhost/ingestion/api/sources/test-mailbox/status || echo "unknown")
        echo "Ingestion status: $status"
        echo "✓ Ingestion process completed"

    - name: View ingestion logs
      if: always()
      run: docker compose logs ingestion

    - name: View service logs on validation failure
      if: failure()
      run: |
        echo "=== Parsing Service Logs ==="
        docker compose logs parsing --tail=100
        echo ""
        echo "=== Chunking Service Logs ==="
        docker compose logs chunking --tail=100
        echo ""
        echo "=== Embedding Service Logs ==="
        docker compose logs embedding --tail=100
        echo ""
        echo "=== Orchestrator Service Logs ==="
        docker compose logs orchestrator --tail=100

    - name: Test gateway health endpoint
      run: |
        echo "Testing gateway health..."
        max_attempts=10
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          if curl -k -f https://localhost/health 2>/dev/null; then
            echo "✓ Gateway is healthy"
            exit 0
          fi
          echo "Attempt $attempt/$max_attempts: Gateway not responding yet..."
          sleep 3
          attempt=$((attempt + 1))
        done
        echo "❌ Gateway failed to respond after $max_attempts attempts"
        docker compose logs gateway --tail=50
        exit 1

    - name: Test gateway health endpoint
      run: |
        echo "Testing API Gateway health..."
        max_attempts=10
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          if curl -k -f https://localhost/health 2>/dev/null; then
            echo "✓ API Gateway is healthy"
            exit 0
          fi
          echo "Attempt $attempt/$max_attempts: Gateway not responding yet..."
          sleep 3
          attempt=$((attempt + 1))
        done
        echo "❌ Gateway failed to respond after $max_attempts attempts"
        docker compose logs gateway --tail=50
        exit 1

    - name: Test reporting service health endpoint
      run: |
        echo "Testing reporting service (via gateway)..."
        max_attempts=10
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          if curl -k -f https://localhost/reporting/health 2>/dev/null; then
            echo "✓ Reporting service is healthy"
            exit 0
          fi
          echo "Attempt $attempt/$max_attempts: Reporting service not responding yet..."
          sleep 3
          attempt=$((attempt + 1))
        done
        echo "❌ Reporting service failed to respond after $max_attempts attempts"
        docker compose logs reporting --tail=50
        exit 1

    - name: Test auth service health endpoint
      run: |
        echo "Testing auth service (via gateway)..."
        max_attempts=10
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          if curl -k -f https://localhost/auth/health 2>/dev/null; then
            echo "✓ Auth service is healthy"
            exit 0
          fi
          echo "Attempt $attempt/$max_attempts: Auth service not responding yet..."
          sleep 3
          attempt=$((attempt + 1))
        done
        echo "❌ Auth service failed to respond after $max_attempts attempts"
        docker compose logs auth --tail=50
        exit 1

    - name: Test reporting API endpoint (via gateway)
      run: |
        echo "Testing reports API (via gateway)..."
        curl -k -f https://localhost/reporting/api/reports || (docker compose logs reporting --tail=50 && exit 1)

    - name: Validate reports are generated (end-to-end)
      run: |
        echo "Validating reports exist after end-to-end run..."
        # Fetch reports JSON and assert count > 0 (black-box via reporting API)
        json=$(curl -k -s https://localhost/reporting/api/reports)
        echo "$json" | python -c 'import json,sys; data=json.load(sys.stdin); cnt=data.get("count",0); print(f"Reports count: {cnt}"); exit(0 if cnt>0 else 1)'
        echo "✓ Reports validation passed"

    - name: Test ui service root endpoint (via gateway)
      run: |
        echo "Testing ui service root (via gateway)..."
        curl -k -f https://localhost/ui/ || (docker compose logs ui --tail=50 && exit 1)

    - name: Test reports API via gateway
      run: |
        echo "Testing reports API via gateway..."
        json=$(curl -kf https://localhost/reporting/api/reports)
        echo "$json" | python -c 'import json,sys; data=json.load(sys.stdin); cnt=data.get("count",0); print(f"Reports count: {cnt}"); exit(0 if cnt>0 else 1)'

    - name: Test Grafana health endpoint (via gateway)
      run: |
        echo "Testing Grafana (via gateway)..."
        curl -k -f https://localhost/grafana/api/health || exit 1

    - name: Test Prometheus health endpoint
      run: |
        echo "Testing Prometheus..."
        curl -f http://localhost:9090/-/healthy || exit 1

    - name: Test Loki health endpoint
      run: |
        echo "Testing Loki..."
        max_attempts=30
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          if curl -f http://localhost:3100/ready 2>/dev/null; then
            echo "Loki is ready"
            exit 0
          fi
          echo "Attempt $attempt/$max_attempts: Loki not ready yet, waiting..."
          sleep 5
          attempt=$((attempt + 1))
        done
        echo "Loki failed to become ready after $max_attempts attempts"
        exit 1

    - name: View service logs
      if: always()
      run: docker compose logs --tail=50

    - name: Stop all services
      if: always()
      run: docker compose down

    - name: Verify clean shutdown
      if: always()
      run: |
        echo "Verifying all containers stopped..."
        if [ "$(docker compose ps -q | wc -l)" -eq 0 ]; then
          echo "✓ All services stopped successfully"
        else
          echo "✗ Some services failed to stop"
          docker compose ps
          exit 1
        fi
