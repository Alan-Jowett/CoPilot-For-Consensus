# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Copilot-for-Consensus contributors

"""Atheris fuzzing tests for ingestion file upload parsing.

This module tests security-critical file parsing functionality to detect:
- Path traversal vulnerabilities in filename sanitization
- Crashes from malformed mbox files
- Extension validation bypasses

Note: Archive extraction (ZIP, TAR) fuzzing is deferred to a future PR.
This module focuses on filename validation and mbox parsing as the first
priority for ingestion security. ZIP bomb and TAR extraction fuzzing will
be added in a follow-up issue.

IMPORTANT: Atheris tests run as standalone scripts (python test_ingestion_upload_fuzzing.py),
NOT through pytest. This is because atheris uses libFuzzer's own execution model
which is incompatible with pytest's test runner.

Usage:
    python tests/test_ingestion_upload_fuzzing.py -atheris_runs=10000
"""

import sys
from pathlib import Path

# Add parent directories to path for imports
repo_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(repo_root / "ingestion"))

try:
    import atheris
except ImportError:
    atheris = None


def fuzz_filename_sanitization(data: bytes) -> None:
    """Fuzz filename sanitization to detect path traversal vulnerabilities.

    Tests that filename sanitization handles:
    - Path traversal attempts (../, ..\\, etc.)
    - Absolute paths (/etc/passwd, C:\\Windows\\System32\\)
    - Null bytes and special characters
    - Unicode and encoding attacks
    - Empty or malformed filenames
    - Extremely long filenames

    Args:
        data: Random bytes generated by the fuzzer
    """
    from app.api import _sanitize_filename

    try:
        if not data:
            return

        # Convert bytes to string with various encodings to test robustness
        for encoding in ['utf-8', 'latin-1', 'ascii']:
            try:
                filename = data.decode(encoding, errors='ignore')

                # Test sanitization
                sanitized = _sanitize_filename(filename)

                # Verify security properties
                # 1. No path separators (regex replaces any non-alphanumeric chars
                # except dots, hyphens, and underscores with underscores)
                assert '/' not in sanitized, f"Path separator in sanitized name: {sanitized}"
                assert '\\' not in sanitized, f"Windows path separator in sanitized name: {sanitized}"

                # 2. No absolute paths
                assert not sanitized.startswith('/'), f"Absolute path detected: {sanitized}"
                # Verify that colons in the input are actually replaced (e.g., "C:\" -> "C_...")
                if ':' in filename:
                    assert ':' not in sanitized, (
                        f"Colon not replaced during sanitization: {filename!r} -> {sanitized!r}"
                    )

                # 3. No null bytes
                assert '\x00' not in sanitized, f"Null byte in sanitized name: {sanitized}"

                # 4. Reasonable length (should be truncated)
                assert len(sanitized) <= 255, f"Filename too long: {len(sanitized)}"

                # 5. Hidden files starting with '.' are prefixed with "upload_"
                assert sanitized, "Sanitized filename is empty"
                # Verify hidden file handling: either doesn't start with dot, or has been
                # prefixed with "upload_" (per api.py lines 91-92)
                assert not sanitized.startswith('.') or sanitized.startswith('upload_.'), (
                    f"Hidden file not properly prefixed: {sanitized}"
                )

            except (UnicodeDecodeError, UnicodeError):
                # Expected for invalid encodings
                pass

    except AssertionError:
        # Re-raise assertion errors (these indicate security issues)
        raise
    except Exception as e:
        # Catch unexpected exceptions that might indicate bugs
        # In production, we want sanitization to be robust and not crash
        if "NoneType" not in str(e):  # Ignore common test artifacts
            print(f"Unexpected exception in sanitization: {type(e).__name__}: {e}")
            print(f"Input (hex): {data.hex()}")


def fuzz_extension_validation(data: bytes) -> None:
    """Fuzz file extension validation to detect bypass attempts.

    Tests that extension validation properly handles:
    - Case variations (.MBOX, .Mbox, .MbOx)
    - Compound extensions (.tar.gz, .tar.bz2)
    - Extension confusion (.mbox.exe, .zip.txt)
    - Null byte injection (.mbox\x00.exe)
    - Unicode and homograph attacks

    Args:
        data: Random bytes generated by the fuzzer
    """
    from app.api import _split_extension, _validate_file_extension

    try:
        if not data:
            return

        filename = data.decode('utf-8', errors='ignore')

        # Test extension splitting
        name, ext = _split_extension(filename)

        # Verify splitting properties
        if filename:
            assert isinstance(name, str), "Name must be string"
            assert isinstance(ext, str), "Extension must be string"
            # Verify that concatenation produces a string
            if ext:
                reconstructed = name + ext
                assert isinstance(reconstructed, str), "Reconstructed filename must be string"

        # Test validation
        is_valid = _validate_file_extension(filename)

        # Verify validation properties
        assert isinstance(is_valid, bool), "Validation must return bool"

        # If validation passes, extension must be in allowed list
        if is_valid:
            lower_ext = ext.lower()
            allowed = {".mbox", ".zip", ".tar", ".tar.gz", ".tgz"}
            assert lower_ext in allowed, f"Invalid extension passed validation: {ext}"

    except (UnicodeDecodeError, UnicodeError):
        # Expected for invalid UTF-8
        pass
    except Exception as e:
        # Extension validation should never crash
        print(f"Extension validation crashed: {type(e).__name__}: {e}")
        print(f"Input (hex): {data.hex()}")
        raise


def fuzz_mbox_parsing(data: bytes) -> None:
    """Fuzz mbox file parsing to detect crashes and hangs.

    Tests that mbox parsing handles:
    - Malformed mbox headers
    - Invalid email structures
    - Extremely large messages
    - Invalid character encodings
    - Missing required fields
    - Circular references

    Args:
        data: Random bytes generated by the fuzzer
    """
    import mailbox
    import os
    import tempfile

    try:
        # Only process small inputs to avoid timeouts
        # Real-world mbox files are large, but fuzzing should be fast
        # Note: Memory exhaustion testing with large files (50MB+) is deferred
        # to integration tests. This fuzzer focuses on structural/encoding bugs.
        if len(data) > 10000:  # 10KB limit for fuzzing
            return

        # Create temporary directory for mbox files to ensure cleanup
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = os.path.join(temp_dir, "fuzz_test.mbox")
            with open(temp_path, 'wb') as f:
                f.write(data)

            try:
                # Fuzz Python's standard mailbox module, which is the foundation
                # for the parsing service's MessageParser (parsing/app/parser.py).
                # This tests for crashes in the underlying library.
                # Application-specific parsing logic (header extraction, threading,
                # etc.) is covered by service integration tests, not fuzzing.
                mbox = mailbox.mbox(temp_path)

                # Try to iterate through messages (limited to prevent hangs)
                count = 0
                max_messages = 10
                for message in mbox:
                    count += 1
                    if count >= max_messages:
                        break

                    # Try to access common headers
                    _ = message.get('From')
                    _ = message.get('To')
                    _ = message.get('Subject')
                    _ = message.get('Message-ID')
                    _ = message.get('Date')

                # Close mbox before directory cleanup
                mbox.close()

            except (mailbox.Error, KeyError, ValueError, OSError):
                # These are expected for malformed mbox files
                pass

    except (mailbox.Error, KeyError, ValueError, OSError):
        # These are expected for malformed mbox files
        pass
    except Exception as e:
        # Unexpected exceptions might indicate bugs
        # But many exceptions are expected for malformed data
        if not isinstance(e, (StopIteration, AttributeError)):
            print(f"Unexpected mbox parsing exception: {type(e).__name__}: {e}")


def main() -> None:
    """Set up and run the fuzzer."""
    if atheris is None:
        print("Atheris not available - skipping fuzzing test")
        print("Install with: pip install atheris")
        return

    # Determine which fuzzer to run based on command line args
    target = "sanitization"  # default

    for arg in sys.argv[1:]:
        if arg.startswith("-target="):
            target = arg.split("=", 1)[1]

    print(f"Running fuzzer for: {target}")

    if target == "sanitization":
        atheris.Setup(sys.argv, fuzz_filename_sanitization)
    elif target == "extension":
        atheris.Setup(sys.argv, fuzz_extension_validation)
    elif target == "mbox":
        atheris.Setup(sys.argv, fuzz_mbox_parsing)
    else:
        print(f"Unknown target: {target}")
        print("Available targets: sanitization, extension, mbox")
        return

    atheris.Fuzz()


if __name__ == "__main__":
    main()
